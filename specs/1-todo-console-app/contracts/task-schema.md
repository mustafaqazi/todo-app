# Task Entity Schema Contract

**Feature**: Phase I - Todo In-Memory Python Console App
**Date**: 2025-12-30
**Purpose**: Formal specification of the Task data structure, validation rules, and API contracts

---

## Task Schema Definition

### JSON Schema (Formal)

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Task",
  "description": "A single work item in the TODO application",
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "description": "Unique auto-incremented identifier (starting from 1)",
      "minimum": 1,
      "exclusiveMinimum": false
    },
    "title": {
      "type": "string",
      "description": "Non-empty task title",
      "minLength": 1
    },
    "description": {
      "type": "string",
      "description": "Optional task description (can be empty)",
      "minLength": 0
    },
    "complete": {
      "type": "boolean",
      "description": "Task completion status",
      "default": false
    }
  },
  "required": ["id", "title", "description", "complete"],
  "additionalProperties": false
}
```

### Python Type Annotation

```python
from typing import TypedDict

class Task(TypedDict):
    """Task entity for Phase I TODO application."""
    id: int              # Unique auto-incremented identifier (≥ 1)
    title: str           # Non-empty task title
    description: str     # Optional description (can be empty)
    complete: bool       # Completion status (True = complete, False = incomplete)
```

### Example Instances

**Complete Task**:
```python
{
    'id': 1,
    'title': 'Buy groceries',
    'description': 'Milk, bread, eggs, cheese',
    'complete': True
}
```

**Incomplete Task**:
```python
{
    'id': 2,
    'title': 'Write report',
    'description': '',
    'complete': False
}
```

---

## Field Specifications

### Field: `id` (int)

| Aspect | Specification |
|--------|--------------|
| Type | `int` |
| Constraints | Must be ≥ 1, unique across all tasks in session |
| Mutability | Immutable after creation |
| Assignment | Auto-incremented via `max([t['id'] for t in tasks]) + 1 if tasks else 1` |
| Validation | No explicit validation needed; generated by system |
| Display | Decimal integer (e.g., `1`, `2`, `42`) |

**Assignment Logic**:
```python
def get_next_id(tasks: list[dict]) -> int:
    """Generate next task ID (resilient after deletions)."""
    return max([t['id'] for t in tasks], default=0) + 1
```

**Notes**:
- IDs are never reused, even if a task with a lower ID is deleted
- This design is resilient; no separate ID counter required
- O(n) scan acceptable for Phase I scope

---

### Field: `title` (str)

| Aspect | Specification |
|--------|--------------|
| Type | `str` (Unicode text) |
| Constraints | Non-empty after whitespace stripping; single-line |
| Mutability | Mutable (can be updated via `update_task`) |
| Validation | Must have ≥ 1 non-whitespace character |
| Display | As-is in table; may wrap if long (500+ chars) |
| Default | No default; required on creation |

**Validation Logic**:
```python
def validate_title(title: str) -> None:
    """Validate task title."""
    if not title or not title.strip():
        raise ValueError("Title cannot be empty.")
```

**Notes**:
- No length limit enforced (accepts very long titles)
- No special character restrictions
- Whitespace-only strings (`"   "`) are invalid
- Multiple tasks can have identical titles (no uniqueness constraint)

---

### Field: `description` (str)

| Aspect | Specification |
|--------|--------------|
| Type | `str` (Unicode text) |
| Constraints | Optional; can be empty string `""` |
| Mutability | Mutable (can be updated via `update_task`) |
| Validation | No validation (any string accepted, including empty) |
| Display | As-is in table; may wrap if long |
| Default | Empty string `""` |

**Notes**:
- Empty descriptions are valid and common (users may add title only)
- No length limit enforced
- No special character restrictions
- Multiple tasks can have identical descriptions
- When displaying, empty descriptions show as blank column

---

### Field: `complete` (bool)

| Aspect | Specification |
|--------|--------------|
| Type | `bool` |
| Constraints | Must be `True` or `False` |
| Mutability | Mutable (toggled via `mark_complete` / `mark_incomplete`) |
| Validation | No validation needed (Python bool is always valid) |
| Display | `[x]` if `True`, `[ ]` if `False` |
| Default | `False` on creation |

**State Transitions**:
```python
def mark_complete(tasks: list[dict], task_id: int) -> None:
    """Mark task as complete."""
    task = get_task(tasks, task_id)
    if task is None:
        raise ValueError(f"Task ID {task_id} not found.")
    task['complete'] = True

def mark_incomplete(tasks: list[dict], task_id: int) -> None:
    """Mark task as incomplete."""
    task = get_task(tasks, task_id)
    if task is None:
        raise ValueError(f"Task ID {task_id} not found.")
    task['complete'] = False
```

---

## Collection Schema: Task List

### Structure

```python
tasks: list[dict] = []
```

All tasks are stored in a single Python list. Each element is a task dict.

### Properties

| Property | Value |
|----------|-------|
| Type | `list[dict]` (mutable list of task dictionaries) |
| Order | Insertion order (oldest first) |
| Size | Dynamic; no fixed limit (Phase I suitable for <1000 tasks) |
| Uniqueness | Task IDs are unique; titles/descriptions non-unique |
| Cardinality | 0 or more tasks per session |

### Example State

**Empty list**:
```python
tasks = []
```

**Three-task list**:
```python
tasks = [
    {'id': 1, 'title': 'Buy milk', 'description': 'From grocery store', 'complete': True},
    {'id': 2, 'title': 'Write report', 'description': '', 'complete': False},
    {'id': 3, 'title': 'Exercise', 'description': '30-minute run', 'complete': False},
]
```

### Iteration & Querying

**Iterate all tasks**:
```python
for task in tasks:
    print(task['title'], task['complete'])
```

**Find task by ID**:
```python
def get_task(tasks: list[dict], task_id: int) -> dict | None:
    """Find task by ID; return None if not found."""
    for task in tasks:
        if task['id'] == task_id:
            return task
    return None
```

**Count incomplete tasks**:
```python
incomplete_count = sum(1 for task in tasks if not task['complete'])
```

---

## Serialization & Display

### Display Format (for `list` command)

**Header**:
```
ID | Title | Description | Status
```

**Row format**:
```
{id:<5} | {title:<30} | {description:<40} | {status}
```

Where:
- `id`: Left-aligned in 5-character field
- `title`: Left-aligned in 30-character field
- `description`: Left-aligned in 40-character field
- `status`: `[x]` (complete) or `[ ]` (incomplete)

**Example**:
```
ID | Title | Description | Status
=====================================
1  | Buy milk | From grocery store | [x]
2  | Write report |  | [ ]
3  | Exercise | 30-minute run | [ ]
```

### Programmatic Representation

Tasks are represented as plain Python dicts (no class instances per Constitution Principle I).

```python
task = {
    'id': 1,
    'title': 'Buy milk',
    'description': 'From grocery store',
    'complete': True
}

# Access fields
print(task['id'])           # 1
print(task['title'])        # "Buy milk"
print(task['description'])  # "From grocery store"
print(task['complete'])     # True

# Update fields
task['complete'] = False
task['title'] = 'Buy milk and bread'
```

---

## Validation Rules & Error Handling

### Creation Validation (`add_task`)

| Check | Rule | Error | Handling |
|-------|------|-------|----------|
| Title present | Title provided by user | `ValueError` | Prompt again |
| Title non-empty | `len(title.strip()) > 0` | `ValueError("Title cannot be empty.")` | Prompt again |
| Description optional | Can be empty | None | Accept empty string |
| ID unique | Auto-generated, always unique | None | Generated by system |
| Complete default | Set to `False` | None | Set by system |

**Pseudocode**:
```python
def add_task(tasks: list[dict], title: str, description: str) -> None:
    if not title or not title.strip():
        raise ValueError("Title cannot be empty.")

    next_id = max([t['id'] for t in tasks], default=0) + 1
    task = {
        'id': next_id,
        'title': title,
        'description': description,
        'complete': False
    }
    tasks.append(task)
```

### Update Validation (`update_task`)

| Check | Rule | Error | Handling |
|-------|------|-------|----------|
| Task exists | ID found in list | `ValueError("Task ID X not found.")` | Display error; don't update |
| New title non-empty | If provided, `len(title.strip()) > 0` | `ValueError("Title cannot be empty.")` | Prompt again; don't update |
| New description optional | Can be empty if provided | None | Accept any string |

### Query Validation (`get_task`, `mark_*`, `delete_task`)

| Check | Rule | Error | Handling |
|-------|------|-------|----------|
| Task exists | ID found in list | `ValueError("Task ID X not found.")` | Display error; don't modify |
| ID is integer | Argument parsed as int | `ValueError("Invalid task ID...")` | Display error; re-prompt |

---

## Constraints & Invariants

### Session-Level Invariants

**Invariant 1: Task ID Uniqueness**
```python
assert len(set(t['id'] for t in tasks)) == len(tasks)
```
All task IDs in the session are unique. Never reused.

**Invariant 2: ID Sequence**
```python
ids = sorted([t['id'] for t in tasks])
if ids:
    assert ids[0] >= 1 and ids[-1] >= 1
```
IDs are positive integers; sequence may have gaps (after deletions).

**Invariant 3: Required Fields Present**
```python
for task in tasks:
    assert 'id' in task and 'title' in task and 'description' in task and 'complete' in task
    assert isinstance(task['id'], int)
    assert isinstance(task['title'], str)
    assert isinstance(task['description'], str)
    assert isinstance(task['complete'], bool)
```
Every task dict has all required fields with correct types.

**Invariant 4: Non-Empty Titles**
```python
for task in tasks:
    assert task['title'].strip() != ""
```
All tasks have non-empty titles (no whitespace-only strings).

---

## Backward Compatibility & Evolution

### Phase I Contract

This schema defines the Phase I task model. Future phases must maintain backward compatibility:

- **Phase II (Persistence)**: Same schema; add load/save logic
- **Phase II+ (Extensions)**: Add optional fields (due_date, priority, tags) without breaking existing tasks

### Migration Strategy (if needed)

If schema changes, ensure:
1. New fields have defaults (don't break existing tasks)
2. Old fields are not removed (backward compatible)
3. ID uniqueness preserved
4. Title non-empty constraint maintained

---

## Performance & Scalability

### Phase I Limits

- **Maximum tasks**: ~1000 (design limit; beyond this, O(n) operations slow)
- **ID lookup time**: O(n) linear search (acceptable for Phase I)
- **Memory usage**: ~100 bytes per task (3 strings + int + bool)
- **List display time**: O(n) to format all tasks (acceptable for <1000 tasks)

### Future Optimization Opportunities

- Hash-based ID lookup (dict<id, task>) for O(1) find
- Indexing by title/completion status for filtering
- Pagination for very large lists
- Caching of formatted output
